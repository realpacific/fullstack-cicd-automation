aliases:
- netrc: &netrc
    name: Heroku init (Setting up .netrc)
    command: |-
      # https://discuss.circleci.com/t/heroku-command-requires-login/7996/7
      cat >~/.netrc <<EOF
      machine api.heroku.com
        login ${HEROKU_USER}
        password ${HEROKU_PWD}
      machine git.heroku.com
        login ${HEROKU_USER}
        password ${HEROKU_PWD}
      EOF
      chmod 600 ~/.netrc

version: 2.1

executors:
  node-executor:
    docker:
    - image: circleci/node

jobs:
  build-ui:
    executor: node-executor
    steps:
    - checkout
    - setup_remote_docker
    - run:
        name: Setup npm & heroku
        command: |-
          sudo apt-get install nodejs
          curl https://cli-assets.heroku.com/install.sh | sh
    - run:
        name: Cleanup
        command: |-
          docker rm -f verdaccio 2>/dev/null || true
          docker run -it -d --rm --name verdaccio -p 4873:4873 verdaccio/verdaccio
          # remove if any or fail silently
          docker rm -f my_distro 2>/dev/null || true
          docker rm -f e2e-container 2>/dev/null || true
          docker rm -f web 2>/dev/null || true;
          export TAG=$(git log -1 --format=%h)
          echo $TAG
          docker-compose -f ~/project/docker-compose.yml down && docker-compose -f ~/project/docker-compose.yml up -d web
    - restore_cache:
        key: dependency-cache-{{ checksum "libraries/package-lock.json" }}
    - run: *netrc
    - run:
        name: Building dope-table
        command: |
          cd libraries
          npm install
          npm run build:dope-table
    - save_cache:
        key: dependency-cache-{{ checksum "libraries/package-lock.json" }}
        paths:
        - ./libraries/node_modules
    - run:
        name: Setup infrastructure
        command: |-
          # the one with service will be named `verdaccio`
          # we start another container with curl in the same network as `verdaccio`, this way we have
          # all exposed ports from `verdaccio` available on `localhost` in this new container
          docker run --rm -it -d --network container:verdaccio --name my_distro node:13.7.0-alpine3.11

          # Since node uses Alpine linux
          docker exec my_distro sh -c 'apk add curl'
          docker exec my_distro sh -c 'apk add jq'
          docker exec my_distro sh -c 'npm cache verify; npm install -g npm; npm cache clean --force'
    - run:
        name: Change to production url
        command: |-
          #docker exec my_distro sh -c ""BASE='https://prashant-flask-app.herokuapp.com' && sed -i -e 's#http://localhost:5000#'""$BASE""'#g' ui/cypress.json""
          export BACKEND_URL=$(heroku info -a prashant-flask-app | grep Web | awk '{ print $3 }' | sed 's/.$//')
          BASE="baseUrl: "\"$BACKEND_URL\"; sed -i "s#baseUrl.*#$BASE#g" ui/src/environments/environment.prod.ts
          cat ui/src/environments/environment.prod.ts
    - run:
        name: Login to npm
        command: |-
          DATA="{\"name\": \"uname\", \"password\": \"mypassword\", \"type\": \"user\"}"

          docker exec my_distro sh -c "curl -s -H 'Accept: application/json' \
                           -H 'Content-Type:application/json' \
                          -X PUT --data '${DATA}'  \
                          --user uname:mypassword http://localhost:4873/-/user/org.couchdb.user:uname -o tmp.json"

          docker exec my_distro sh -c "chmod a=rwx tmp.json"

          # Output is inserted at {} as -I{}
          docker exec my_distro sh -c "cat tmp.json | jq '.token' | xargs -I{} npm set //localhost:4873/:_authToken={}"
    - run:
        name: Publish (Work-around to publish/install npm package to/from Verdaccio)
        command: |-
          echo '>>> Publishing dope-table'
          cd libraries
          docker cp dist my_distro:/
          docker exec my_distro sh -c "cd dist/dope-table; npm publish --registry=http://localhost:4873 --allow-same-version=true || true"
          docker exec my_distro sh -c "cd ../.. && rm -r dist || true"
          echo '>>> Published'

          cd ..
          # Copy ui directory to container to install dope-table
          docker cp ui my_distro:/

          echo '>>> Installing dope-table'
          docker exec my_distro sh -c "cd ui; npm install dope-table --registry=http://localhost:4873 --no-package-lock"

          echo '>>> Installing from npmjs'
          docker exec my_distro sh -c "cd ui; npm install --registry=https://registry.npmjs.org --no-package-lock; npm run build"

          # Copy generated folder into ./ui/release. The Dockerfile will be inside ./ui/.
          # This is our production bundle that will be send to ngnix container.
          docker cp my_distro:/ui/dist ui/release

          # build contains node_modules, where we can run e2e against;
          # e2e tests are run on dev environment, NOT production.
          docker cp my_distro:/ui ui/build
    - run:
        name: Copy to workspace
        command: |-
          mkdir -p workspace
    - persist_to_workspace:
        root: workspace
        paths:
        - ui/build
        - ui/release
        - Dockerfile


  test-frontend:
    executor: node-executor
    steps:
    - attach_workspace:
        at: /workspace
    - run:
        name: Running e2e test
        command: |-
          cd ui
          sleep 20
          docker run --rm -it -d --network container:web --name e2e-container cypress/base:13.6.0
          docker cp build e2e-container:/build
          docker exec e2e-container sh -c "cd build; echo '>>>> Contents of /build directory:'; ls -la"
          docker exec e2e-container sh -c "cd build; npm install -g @angular/cli"
          docker exec e2e-container sh -c "cd build; npm run e2e:headless"
          # Copy the test output in host.
          docker cp e2e-container:/build/cypress ~/project/output
    - store_artifacts:
        path: ~/project/output
    - run:
        name: Publishing Image to DockerHub
        command: |-
          TAG=$(git log -1 --format=%h)
          IMAGE=ng-app:${TAG}
          cd ui
          # docker build -t $DOCKER_USERNAME/$IMAGE -f Dockerfile .
          # docker login -u $DOCKER_USERNAME -p $DOCKER_PWD
          # docker push $DOCKER_USERNAME/$IMAGE
    - run:
        name: Deploy to Heroku
        command: |-
          docker build -t web -f ./Dockerfile .
          docker tag web registry.heroku.com/prashant-ng-app/web
          docker login --username=$(heroku auth:whoami) --password=$(heroku auth:token) registry.heroku.com
          docker push registry.heroku.com/prashant-ng-app/web
          heroku container:release web -a prashant-ng-app
          echo '>>>> Deployed'
          export NG_URL=$(heroku info -a prashant-ng-app | grep Web | awk '{ print $3 }')
          echo "Service running at $NG_URL"

  build-backend:
    environment:
      IMAGE_NAME: flask-app
      REGISTRY:
    docker:
    - image: circleci/node
    steps:
    - checkout
    - setup_remote_docker
    - run:
        name: Install Heroku
        command: |-
          curl https://cli-assets.heroku.com/install.sh | sh
    - run:
        name: Building Python project
        command: |
          git submodule update --init --recursive
          echo $(ls)
          export TAG=$(git log -1 --format=%h)
          echo IMAGE=${IMAGE_NAME}:${TAG}
    - run:
        name: Push to DockerHub
        command: |-
          #docker build -t $DOCKER_USERNAME/$IMAGE_NAME:$TAG -f ./backend/Dockerfile .
          #docker login -u $DOCKER_USERNAME -p $DOCKER_PWD
          #docker push $DOCKER_USERNAME/$IMAGE_NAME:$TAG
    - run: *netrc
    - run:
        name: Deploy to Heroku
        command: |-
          chmod 600 ~/.netrc
          docker build -t web -f ./backend/Dockerfile .
          docker tag web registry.heroku.com/prashant-flask-app/web
          docker login --username=$(heroku auth:whoami) --password=$(heroku auth:token) registry.heroku.com
          docker push registry.heroku.com/prashant-flask-app/web
          heroku container:release web -a prashant-flask-app

          export BACKEND_URL=$(heroku info -a prashant-flask-app | grep Web | awk '{ print $3 }')
          echo "Service running at $BACKEND_URL"


workflows:
  version: 2.1
  build:
    jobs:
    - build-backend
    - build-ui:
        requires:
        - build-backend
    - test-frontend:
        requires: build-ui
